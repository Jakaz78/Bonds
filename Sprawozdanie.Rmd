---
title: "Sprawozdanie"
author: "Jakub Kaźmierczyk"
date: "2025-05-29"
output: pdf_document
---

# Wprowadzenie

## Opis projektu

cos tam cos tam

## Zmienna objaśniana

CLOSE - zmienna objasniana bedzie rentownosc 10-letnich polskich obligacji skarbowcyh

## Zmienne objaśniające

XAUUSD - cena złota w dolarze amerykańskim\
S&P500 - ETF 500 największych notowanych na giełdzie amerykańskich spółek\
PMI - cos tam\
WIG20 - 20 najwiekszych notowanych na gieldzie polskich spolek\
OIL - cena ropy naftowej za barylke\
UNEMPLOYMENT - stopa bezrobocia w Polsce\
USDPLN - kurs dolara amerykańskiego wyrażony w złotych\
INFLATION - inflacja r/r wobec miesiąca odpowiadającego z roku temu\

## Źródła

[www.stooq.com](https://stooq.pl)\

```{r setup, echo=FALSE, warning=FALSE, message = FALSE}
library(corrplot)
library(readxl)
library(tinytex)
library(ggcorrplot)
library(urca)      
library(tseries)   
library(ggplot2)   
library(dplyr)     
library(tidyr)
library(zoo)
library(gridExtra)
library(grid)

```

# Wczytywanie danych

```{r}
data <- read_excel("data.xlsx")

data <- data[, c("CLOSE", "INFLATION", "XAUUSD", "USDPLN", "WIG20", "S&P500", 
                 "UNEMPLOYMENT", "PMI", "OIL")]

data[] <- lapply(data, function(col) {
  na.approx(col, na.rm = FALSE)
})

Y <- data["CLOSE"]
X <- data[,c("INFLATION","XAUUSD", "USDPLN","WIG20","S&P500","UNEMPLOYMENT",
             "PMI","OIL")]
```

# Podstawowe statystyki

## Zmienna objaśniana

```{r}
summary(Y)
```
Wartości zmiennej objaśnianej wachają się pomiędzy 13,288 a 1,149. Mediana wynosi 5,461 a średnia 5,347. 

## Zmienne objaśniające

```{r}
summary(X)
```
Z 11 zmiennych objaśniających wybrałem 8, których wartość bezwględna korelacji nie przekracza 0.7.

## Macierz korelacji

```{r corrplot, fig.width=20, fig.height=20, echo=FALSE}
cor_matrix <- cor(data, use = "pairwise.complete.obs", method = "pearson")


    corrplot(cor_matrix, method = "color",
           order = "hclust",
           addCoef.col = "black", 
           tl.col = "black", tl.cex = 2.5, cl.cex = 2.5, number.cex=2.6)
```

# Identyfikacja niestacjonarnych zmiennych objaśniających

```{r analiza_stacjonarnosci, warning=FALSE, message=FALSE, fig.height=5, fig.width=7, fig.align='center', echo=FALSE}

is_stationary_test <- function(series) {

  adf_result <- {
    adf <- ur.df(series, type = "trend", selectlags = "AIC")
    adf_stat <- adf@teststat[1]
    adf_crit <- adf@cval[1, "5pct"]
    adf_stat < adf_crit
  }

  kpss_result <- {
    kpss <- kpss.test(series)
    kpss$p.value > 0.05
  }

  return(adf_result && kpss_result)
}


non_stationary_vars <- c()


for (var in colnames(data)) {
  series <- ts(data[[var]])

  if (!is_stationary_test(series)) {
    non_stationary_vars <- c(non_stationary_vars, var)
  }

}
```

## Zidentyfikowane zmienne niestacjonarne:

```{r , echo=FALSE,comment = NA}
for (var in non_stationary_vars) {
  cat(var, "\n")
}

```



## Usunięcie niestacjonarności


```{r usuwanie_niestacjonarnosci, warning=FALSE, message=FALSE, echo=FALSE, comment = NA }

remove_nonstationarity <- function(data, non_stationary_vars, max_diff = 2, show_plots = TRUE) {
  transformed_data <- list()
  diff_info <- list()
  plots_before <- list()
  plots_after <- list()

  for (var_name in colnames(data)) {
    original_series <- data[[var_name]]
    current_series <- original_series
    order <- 0

    if (show_plots) {
      df_plot_before <- data.frame(
        Index = 1:length(original_series),
        Value = as.numeric(original_series)
      )

      plot_before <- ggplot(df_plot_before, aes(x = Index, y = Value)) +
        geom_line(color = "blue", size = 0.7) +
        labs(title = paste("Przed:", var_name),
             x = "Czas", y = "Wartość") +
        theme_minimal() +
        theme(plot.title = element_text(size = 10, face = "bold"))

      plots_before[[var_name]] <- plot_before
    }

    if (var_name %in% non_stationary_vars) {
      for (i in 0:max_diff) {
        test_series <- if (i == 0) original_series else diff(original_series, differences = i)

        if (is_stationary_test(test_series)) {
          order <- i
          current_series <- test_series
          break
        }

        if (i == max_diff) {
          order <- max_diff
          current_series <- diff(original_series, differences = max_diff)
        }
      }
    }

    new_name <- if (order > 0) paste0("D", if(order > 1) order else "", "_", var_name) else var_name
    diff_info[[var_name]] <- list(order = order, name = new_name)
    transformed_data[[new_name]] <- current_series

    if (show_plots) {
      df_plot_after <- data.frame(
        Index = 1:length(current_series),
        Value = as.numeric(current_series)
      )

      plot_after <- ggplot(df_plot_after, aes(x = Index, y = Value)) +
        geom_line(color = "red", size = 0.7) +
        labs(title = paste("Po:", new_name),
             x = "Czas", y = "Wartość") +
        theme_minimal() +
        theme(plot.title = element_text(size = 10, face = "bold"))

      plots_after[[var_name]] <- plot_after
    }
  }

  max_diff_order <- max(sapply(diff_info, function(x) x$order))

  final_df <- as.data.frame(lapply(transformed_data, function(x) {
    c(rep(NA, max_diff_order), x)[1:(nrow(data) + max_diff_order)]
  }))

  final_df <- final_df[complete.cases(final_df), ]

  if (show_plots && length(plots_before) > 0) {
    for (var_name in names(plots_before)) {
      if (var_name %in% names(plots_after)) {
          combined_plot <- arrangeGrob(
            plots_before[[var_name]],
            plots_after[[var_name]],
            ncol = 2
          )
          grid.newpage()
          grid.draw(combined_plot)
      }
    }
  }

  return(list(
    data = final_df,
    diff_info = diff_info,
    plots_before = plots_before,
    plots_after = plots_after
  ))
}

show_all_plots <- function(result, ncol = 2) {
  plots_before <- result$plots_before
  plots_after <- result$plots_after

  all_plots <- list()
  for (var_name in names(plots_before)) {
    if (!is.null(plots_before[[var_name]]) && !is.null(plots_after[[var_name]])) {
      all_plots <- append(all_plots, list(plots_before[[var_name]], plots_after[[var_name]]))
    }
  }

  if (length(all_plots) > 0) {
    num_rows <- ceiling(length(all_plots) / ncol)
    combined <- do.call(arrangeGrob, c(all_plots, list(ncol = ncol)))
    grid.newpage()
    grid.draw(combined)
  }
}
```



```{r wywołanie_funkcji, echo=FALSE, warning=FALSE, message=FALSE, comment = NA}

non_stationary_vars <- c()

for (var in colnames(data)) {
  series <- ts(data[[var]])
  if (!is_stationary_test(series)) {
    non_stationary_vars <- c(non_stationary_vars, var)
  }
}

result <- remove_nonstationarity(data, non_stationary_vars)
data_stationary <- result$data
diff_info <- result$diff_info

for (var in names(diff_info)) {
  info <- diff_info[[var]]
  cat(var, "-> różnicowana", info$order, "razy, nowa nazwa:", info$name, "\n")
}
```

## Ponowne sprawdzenie stacjonarności zmiennych 

```{r sprawdzenie_zmienncyh, echo=FALSE, warning=FALSE, message=FALSE, comment = NA}
for (var in colnames(data_stationary)) {
  series_transformed <- ts(data_stationary[[var]])
  if (is_stationary_test(series_transformed)) {
    cat(var, ": Stacjonarna\n")
  } else {
    cat(var, ": Niestacjonarna")
  }
}
```

## Usunięcie zmiennych o zerowej wariancji ogolnie taki jest podupunkt u \
## tory ale nie usuwalem nic tylko wypisalem 

```{r , echo=FALSE, warning=FALSE, message=FALSE, comment = NA}
for (col_name in colnames(data_stationary)) {
  
      col_cv <- sd(data_stationary[[col_name]]) / mean(data_stationary[[col_name]]) * 100
      col_var <- var(data_stationary[[col_name]])
      cat(col_name, "- Współczynnik zmienności:", col_cv, "%, Wariancja: ", col_var,"\n")
    }
```

# Metoda doboru zmiennych

## Metoda Hellwiga

```{r , echo=FALSE, warning=FALSE, message=FALSE, comment = NA}
hellwig_method_original <- function(y, X) {
  all_vars <- colnames(X)
  R <- cor(cbind(y, X))
  r0 <- R[-1, 1]        
  Rxx <- R[-1, -1]      
  results <- list()
  
  for (k in 1:length(all_vars)) {
    combos <- combn(all_vars, k, simplify = FALSE)
    
    for (combo in combos) {
      indices <- match(combo, all_vars)
      r0_sub <- r0[indices]
      Rxx_sub <- Rxx[indices, indices]
      
      h_kj <- numeric(length(indices))
      
      for (j in seq_along(indices)) {
        if (length(indices) == 1) {
          denom <- 1  
        } else {
          denom <- 1 + sum(abs(Rxx_sub[j, -j]))
        }
        h_kj[j] <- (r0_sub[j]^2) / denom
      }
      
      H_k <- sum(h_kj)
      results[[paste(combo, collapse = ", ")]] <- H_k
    }
  }
  
  df <- data.frame(
    Zmienne = names(results),
    Pojemnosc_Hellwiga = round(unlist(results), 4),
    row.names = NULL
  )
  
  df <- df[order(-df$Pojemnosc_Hellwiga), ]
  return(df)
}
X_stat <- data_stationary[, -1]         
Y_stat <- data_stationary["D_CLOSE"]    
hellwig_result <- hellwig_method_original(Y_stat, X_stat)
```


```{r, echo=FALSE, warning=FALSE, message=FALSE, comment = NA}

cat("\nZmienne składowe w najlepszej kombinacji:\n")
for (zmienna in unlist(strsplit(hellwig_result$Zmienne[1], ", "))) {
  cat(zmienna, "\n")
}
cat("Pojemność Hellwiga dla tej kombinacji:", hellwig_result$Pojemnosc_Hellwiga[1], "\n")
```



















# TEST
```{r, warning=FALSE, message=FALSE, fig.height=5, fig.width=7, fig.align='center', echo=FALSE}

```


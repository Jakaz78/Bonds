---
title: "Sprawozdanie"
author: "Jakub Kaźmierczyk"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    number_sections: true
    latex_engine: xelatex
    highlight: tango
fontsize: 11pt
mainfont: "Times New Roman"
geometry: margin=2.5cm
linestretch: 1.5
lang: "pl"
header-includes:
  - \renewcommand{\contentsname}{Spis treści}
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhf{}
  - \cfoot{\thepage}
---

# Wprowadzenie

## Opis projektu

cos tam cos tam

## Zmienna objaśniana

CLOSE - zmienna objasniana bedzie rentownosc 10-letnich polskich obligacji skarbowcyh

## Zmienne objaśniające

XAUUSD - cena złota w dolarze amerykańskim\
S&P500 - ETF 500 największych notowanych na giełdzie amerykańskich spółek\
PMI - cos tam\
WIG20 - 20 najwiekszych notowanych na gieldzie polskich spolek\
OIL - cena ropy naftowej za barylke\
UNEMPLOYMENT - stopa bezrobocia w Polsce\
USDPLN - kurs dolara amerykańskiego wyrażony w złotych\
INFLATION - inflacja r/r wobec miesiąca odpowiadającego z roku temu\

## Źródła

[www.stooq.com](https://stooq.pl)\

\newpage

# Wczytywanie danych

```{r setup, echo=FALSE, warning=FALSE, message = FALSE}
library(corrplot)
library(readxl)
library(tinytex)
library(ggcorrplot)
library(urca)      
library(tseries)   
library(ggplot2)   
library(dplyr)     
library(tidyr)
library(zoo)
library(gridExtra)
library(grid)

```

```{r}
data <- read_excel("data.xlsx")

data <- data[, c("CLOSE", "INFLATION", "XAUUSD", "USDPLN", "WIG20", "S&P500", 
                 "UNEMPLOYMENT", "PMI", "OIL")]

data[] <- lapply(data, function(col) {
  na.approx(col, na.rm = FALSE)
})

Y <- data["CLOSE"]
X <- data[,c("INFLATION","XAUUSD", "USDPLN","WIG20","S&P500","UNEMPLOYMENT",
             "PMI","OIL")]
```

\newpage

# Podstawowe statystyki

## Zmienna objaśniana

```{r}
summary(Y)
```
Wartości zmiennej objaśnianej wachają się pomiędzy 13,288 a 1,149. Mediana wynosi 5,461 a średnia 5,347. 

## Zmienne objaśniające

```{r}
summary(X)
```
Z 11 zmiennych objaśniających wybrałem 8, których wartość bezwględna korelacji nie przekracza 0.7.

## Macierz korelacji

```{r corrplot, fig.width=20, fig.height=20, echo=FALSE}
cor_matrix <- cor(data, use = "pairwise.complete.obs", method = "pearson")


    corrplot(cor_matrix, method = "color",
           order = "hclust",
           addCoef.col = "black", 
           tl.col = "black", tl.cex = 2.5, cl.cex = 2.5, number.cex=2.6)
```

# Identyfikacja niestacjonarnych zmiennych objaśniających

```{r analiza_stacjonarnosci, warning=FALSE, message=FALSE, echo=FALSE}

is_stationary_test <- function(series) {

  adf_result <- {
    adf <- ur.df(series, type = "trend", selectlags = "AIC")
    adf_stat <- adf@teststat[1]
    adf_crit <- adf@cval[1, "5pct"]
    adf_stat < adf_crit
  }

  kpss_result <- {
    kpss <- kpss.test(series)
    kpss$p.value > 0.05
  }

  return(adf_result && kpss_result)
}


non_stationary_vars <- c()


for (var in colnames(data)) {
  series <- ts(data[[var]])

  if (!is_stationary_test(series)) {
    non_stationary_vars <- c(non_stationary_vars, var)
  }

}
```

## Zidentyfikowane zmienne niestacjonarne:

```{r , echo=FALSE, comment=NA}
for (var in non_stationary_vars) {
  writeLines(var)
}

```

## Usunięcie niestacjonarności

```{r usuwanie_niestacjonarnosci, message=FALSE, echo=FALSE, comment = NA }

dir.create("plots", showWarnings = FALSE)

remove_nonstationarity <- function(data, non_stationary_vars, max_diff = 2, 
                                   show_plots = TRUE, save_plots = FALSE, 
                                   plot_dir = "plots") {
  if (save_plots && !dir.exists(plot_dir)) {
    dir.create(plot_dir, recursive = TRUE)
  }

  transformed_data <- list()
  diff_info <- list()
  plots_before <- list()
  plots_after <- list()

  for (var_name in colnames(data)) {
    original_series <- data[[var_name]]
    current_series <- original_series
    order <- 0

    if (var_name %in% non_stationary_vars) {
      for (i in 0:max_diff) {
        test_series <- if (i == 0) original_series else diff(original_series, differences = i)

        if (is_stationary_test(test_series)) {
          order <- i
          current_series <- test_series
          break
        }

        if (i == max_diff) {
          order <- max_diff
          current_series <- diff(original_series, differences = max_diff)
        }
      }
    }

    new_name <- if (order > 0) paste0("D", if(order > 1) order else "", "_", var_name) else var_name
    diff_info[[var_name]] <- list(order = order, name = new_name)
    transformed_data[[new_name]] <- current_series

    if (show_plots || save_plots) {
      df_plot_before <- data.frame(Index = 1:length(original_series), Value = as.numeric(original_series))
      df_plot_after  <- data.frame(Index = 1:length(current_series), Value = as.numeric(current_series))

      plot_before <- ggplot(df_plot_before, aes(x = Index, y = Value)) +
        geom_line(color = "blue", size = 0.7) +
        labs(title = paste("Przed:", var_name, var, "Liczba różnicowań: ",order), x = "Czas", y = "Wartość") +
        theme_minimal() +
        theme(plot.title = element_text(size = 10, face = "bold"))

      plot_after <- ggplot(df_plot_after, aes(x = Index, y = Value)) +
        geom_line(color = "red", size = 0.7) +
        labs(title = paste("Po:", new_name), x = "Czas", y = "Wartość") +
        theme_minimal() +
        theme(plot.title = element_text(size = 10, face = "bold"))

      plots_before[[var_name]] <- plot_before
      plots_after[[var_name]] <- plot_after

      if (save_plots) {
        ggsave(filename = file.path(plot_dir, paste0("before_", var_name, ".png")),
               plot = plot_before, width = 6, height = 4, dpi = 300)
        ggsave(filename = file.path(plot_dir, paste0("after_", new_name, ".png")),  # <-- poprawione
               plot = plot_after, width = 6, height = 4, dpi = 300)
      }
    }
    
  }

  max_diff_order <- max(sapply(diff_info, function(x) x$order))

  final_df <- as.data.frame(lapply(transformed_data, function(x) {
    c(rep(NA, max_diff_order), x)[1:(nrow(data) + max_diff_order)]
  }))
  final_df <- final_df[complete.cases(final_df), ]

  return(list(
    data = final_df,
    diff_info = diff_info,
    plots_before = plots_before,
    plots_after = plots_after
  ))
}

```


```{r wywołanie_funkcji, echo=FALSE, warning=FALSE, message=FALSE, comment=NA, fig.align='center', fig.width=10, fig.height=6}

library(gridExtra)
library(grid)

non_stationary_vars <- c()

for (var in colnames(data)) {
  series <- ts(data[[var]])
  if (!is_stationary_test(series)) {
    non_stationary_vars <- c(non_stationary_vars, var)
  }
}

result <- remove_nonstationarity(
  data,
  non_stationary_vars,
  save_plots = TRUE,
  show_plots = FALSE
)

data_stationary <- result$data
diff_info <- result$diff_info
plots_before <- result$plots_before
plots_after <- result$plots_after

for (var in names(diff_info)) {
  info <- diff_info[[var]]
  plot_before <- plots_before[[var]]
  plot_after <- plots_after[[var]]
  
  # 1. Tworzymy layout: wykresy w 1 rzędzie
  gridExtra::grid.arrange(
    plot_before, plot_after,
    ncol = 2,
    top = NULL
  )
  
}
```

## Ponowne sprawdzenie stacjonarności zmiennych 

```{r sprawdzenie_zmienncyh, echo=FALSE, warning=FALSE, message=FALSE, comment = NA}
for (var in colnames(data_stationary)) {
  series_transformed <- ts(data_stationary[[var]])
  if (is_stationary_test(series_transformed)) {
    cat(var, ": Stacjonarna\n")
  } else {
    cat(var, ": Niestacjonarna")
  }
}
```

## Usunięcie zmiennych o zerowej wariancji 

### ogolnie taki jest podupunkt u \
### tory ale nie usuwalem nic tylko wypisalem 

```{r , echo=FALSE, warning=FALSE, message=FALSE, comment = NA}
for (col_name in colnames(data_stationary)) {
  
      col_cv <- sd(data_stationary[[col_name]]) / mean(data_stationary[[col_name]]) * 100
      col_var <- var(data_stationary[[col_name]])
      cat(col_name, "- Współczynnik zmienności:", col_cv, "%, Wariancja: ", col_var,"\n")
    }
```

# Metoda doboru zmiennych

## Metoda Hellwiga

```{r , echo=FALSE, warning=FALSE, message=FALSE, comment = NA}
hellwig_method_original <- function(y, X) {
  all_vars <- colnames(X)
  R <- cor(cbind(y, X))
  r0 <- R[-1, 1]        
  Rxx <- R[-1, -1]      
  results <- list()
  
  for (k in 1:length(all_vars)) {
    combos <- combn(all_vars, k, simplify = FALSE)
    
    for (combo in combos) {
      indices <- match(combo, all_vars)
      r0_sub <- r0[indices]
      Rxx_sub <- Rxx[indices, indices]
      
      h_kj <- numeric(length(indices))
      
      for (j in seq_along(indices)) {
        if (length(indices) == 1) {
          denom <- 1  
        } else {
          denom <- 1 + sum(abs(Rxx_sub[j, -j]))
        }
        h_kj[j] <- (r0_sub[j]^2) / denom
      }
      
      H_k <- sum(h_kj)
      results[[paste(combo, collapse = ", ")]] <- H_k
    }
  }
  
  df <- data.frame(
    Zmienne = names(results),
    Pojemnosc_Hellwiga = round(unlist(results), 4),
    row.names = NULL
  )
  
  df <- df[order(-df$Pojemnosc_Hellwiga), ]
  return(df)
}
X_stat <- data_stationary[, -1]         
Y_stat <- data_stationary["D_CLOSE"]    
hellwig_result <- hellwig_method_original(Y_stat, X_stat)
```


```{r, echo=FALSE, warning=FALSE, message=FALSE, comment = NA}

cat("\nZmienne składowe w najlepszej kombinacji:\n")
for (zmienna in unlist(strsplit(hellwig_result$Zmienne[1], ", "))) {
  writeLines(zmienna)
}
cat("Pojemność Hellwiga dla tej kombinacji:", hellwig_result$Pojemnosc_Hellwiga[1], "\n")
```


---
title: "Sprawozdanie"
author: "Jakub Kaźmierczyk"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
    number_sections: true
    latex_engine: xelatex
    highlight: tango
fontsize: 11pt
mainfont: "Times New Roman"
geometry: margin=2.5cm
linestretch: 1.5
lang: "pl"
header-includes:
  - \renewcommand{\contentsname}{Spis treści}
  - \usepackage{fancyhdr}
  - \pagestyle{fancy}
  - \fancyhf{}
  - \cfoot{\thepage}
---

# Wprowadzenie

## Opis projektu

Projekt ma na celu budowę kompleksowego modelu ekonometrycznego służącego do analizy i prognozowania rentowności 10-letnich polskich obligacji skarbowych. Model zostanie zbudowany na podstawie szeregów czasowych, co umożliwia głębszą analizę dynamicznych zależności ekonomicznych.

## Zmienna objaśniana

**CLOSE** - rentowność 10-letnich polskich obligacji skarbowych

## Zmienne objaśniające

**XAUUSD** - cena złota w dolarze amerykańskim\
**S&P500** - ETF 500 największych notowanych na giełdzie amerykańskich spółek\
**PMI** - wskaźnik aktywności przemysłowej\
**WIG20** - 20 najwiekszych notowanych na gieldzie polskich spolek\
**OIL** - cena ropy naftowej za barylke\
**UNEMPLOYMENT** - stopa bezrobocia w Polsce\
**USDPLN** - kurs dolara amerykańskiego wyrażony w złotych\
**INFLATION** - inflacja rok do roku\

## Źródła

[www.stooq.com](https://stooq.pl)\

\newpage

# Wczytywanie danych

```{r setup, echo=FALSE, warning=FALSE, message = FALSE}
library(corrplot)
library(readxl)
library(tinytex)
library(ggcorrplot)
library(urca)      
library(tseries)   
library(ggplot2)   
library(dplyr)     
library(tidyr)
library(zoo)
library(gridExtra)
library(grid)

```

```{r}
data_all <- read_excel("data.xlsx")

data_all <- data_all[, c("CLOSE", "INFLATION", "XAUUSD", "USDPLN", "WIG20", "S&P500", 
                 "UNEMPLOYMENT", "PMI", "OIL")]

data_all[] <- lapply(data_all, function(col) {
  na.approx(col, na.rm = FALSE)
})


n <- nrow(data_all)
train_size <- floor(0.8 * n)

data <- data_all[1:train_size, , drop = FALSE]
data_test  <- data_all[(train_size + 1):n, , drop = FALSE]

Y <- data["CLOSE"]
X <- data[,c("INFLATION","XAUUSD", "USDPLN","WIG20","S&P500","UNEMPLOYMENT",
             "PMI","OIL")]
```

\newpage

# Podstawowe statystyki

## Zmienna objaśniana

```{r , echo=FALSE}
summary(Y)
```

Wartości zmiennej objaśnianej wachają się pomiędzy 13,288 a 1,149. Mediana wynosi 5,461 a średnia 5,347.

## Zmienne objaśniające

```{r , echo=FALSE}
summary(X)
```

Z 11 zmiennych objaśniających wybrałem 8, których wartość bezwględna korelacji nie przekracza 0.7.

## Macierz korelacji

```{r corrplot, fig.width=20, fig.height=20, echo=FALSE}
cor_matrix <- cor(data, use = "pairwise.complete.obs", method = "pearson")


    corrplot(cor_matrix, method = "color",
           order = "alphabet",
           addCoef.col = "black", 
           tl.col = "black", tl.cex = 2.5, cl.cex = 2.5, number.cex=2.6)
```

\newpage

# Identyfikacja niestacjonarnych zmiennych objaśniających

```{r analiza_stacjonarnosci, warning=FALSE, message=FALSE, echo=FALSE}

check_stationarity <- function(x) {
  adf_test <- ur.df(x, type = "trend")@teststat[1] < ur.df(x, type = "trend")@cval[1,"5pct"]
  kpss_test <- kpss.test(x)$p.value > 0.05
  return(adf_test & kpss_test)
}

non_stationary_vars <- c()

for (var in colnames(data)) {
  series <- ts(data[[var]])
  if (!check_stationarity(series)) {
    non_stationary_vars <- c(non_stationary_vars, var)
  }
}

```

## Sprawdzenie niestacjonarności zmiennych

```{r , echo=FALSE, comment=NA, warning=FALSE, message=FALSE}
stationarity_df <- data.frame(
  Zmienna = colnames(data),
  Stacjonarnosc = sapply(data, function(col) {
    if (check_stationarity(ts(col))) {
      return("Stacjonarna")
    } else {
      return("Niestacjonarna")
    }
  })
)


knitr::kable(stationarity_df, row.names = FALSE)

```

## Usunięcie niestacjonarności

```{r usuwanie_niestacjonarnosci, message=FALSE, echo=FALSE, comment = NA }

dir.create("plots", showWarnings = FALSE)

remove_nonstationarity <- function(data, non_stationary_vars, max_diff = 2, 
                                   show_plots = TRUE, save_plots = FALSE, 
                                   plot_dir = "plots") {
  if (save_plots && !dir.exists(plot_dir)) {
    dir.create(plot_dir, recursive = TRUE)
  }

  transformed_data <- list()
  diff_info <- list()
  plots_before <- list()
  plots_after <- list()

  for (var_name in colnames(data)) {
    original_series <- data[[var_name]]
    current_series <- original_series
    order <- 0

    if (var_name %in% non_stationary_vars) {
      for (i in 1:max_diff) {
        test_series <- if (i == 0) original_series else diff(original_series, differences = i)

        if (check_stationarity(test_series)) {
         order <- i
         current_series <- test_series
         break
       }

        if (i == max_diff) {
          order <- max_diff
          current_series <- diff(original_series, differences = max_diff)
        }
      }
    }

   new_name <- if (order > 0) {
     paste0("D", if(order > 1) order else "", "_", var_name)} else {
     var_name
   }
   
   diff_info[[var_name]] <- list(order = order, name = new_name)
   transformed_data[[new_name]] <- current_series

    if (show_plots || save_plots) {
      df_plot_before <- data.frame(Index = 1:length(original_series), Value = as.numeric(original_series))
      df_plot_after  <- data.frame(Index = 1:length(current_series), Value = as.numeric(current_series))

      plot_before <- ggplot(df_plot_before, aes(x = Index, y = Value)) +
        geom_line(color = "blue", size = 0.7) +
        labs(title = paste("Przed:", var_name, "Liczba różnicowań: ",order), x = "Czas", y = "Wartość") +
        theme_minimal() +
        theme(plot.title = element_text(size = 10, face = "bold"))

      plot_after <- ggplot(df_plot_after, aes(x = Index, y = Value)) +
        geom_line(color = "red", size = 0.7) +
        labs(title = paste("Po:", new_name), x = "Czas", y = "Wartość") +
        theme_minimal() +
        theme(plot.title = element_text(size = 10, face = "bold"))

      plots_before[[var_name]] <- plot_before
      plots_after[[var_name]] <- plot_after

      if (save_plots) {
        ggsave(filename = file.path(plot_dir, paste0("before_", var_name, ".png")),
               plot = plot_before, width = 6, height = 4, dpi = 300)
        ggsave(filename = file.path(plot_dir, paste0("after_", new_name, ".png")),  # <-- poprawione
               plot = plot_after, width = 6, height = 4, dpi = 300)
      }
    }
    
  }

  max_diff_order <- max(sapply(diff_info, function(x) x$order))

  final_df <- as.data.frame(lapply(transformed_data, function(x) {
    c(rep(NA, max_diff_order), x)[1:(nrow(data) + max_diff_order)]
  }))
  final_df <- final_df[complete.cases(final_df), ]

  return(list(
    data = final_df,
    diff_info = diff_info,
    plots_before = plots_before,
    plots_after = plots_after
  ))
}

```

```{r wywołanie_funkcji, echo=FALSE, warning=FALSE, message=FALSE, comment=NA, fig.align='center', fig.width=10, fig.height=6}

non_stationary_vars <- c()

for (var in colnames(data)) {
  series <- ts(data[[var]])
  if (!check_stationarity(series)) {
    non_stationary_vars <- c(non_stationary_vars, var)
  }
}

result <- remove_nonstationarity(
  data,
  non_stationary_vars,
  save_plots = TRUE,
  show_plots = FALSE
)

data_stationary <- result$data
diff_info <- result$diff_info
plots_before <- result$plots_before
plots_after <- result$plots_after

for (var in names(diff_info)) {
  info <- diff_info[[var]]
  plot_before <- plots_before[[var]]
  plot_after <- plots_after[[var]]
  
  gridExtra::grid.arrange(
    plot_before, plot_after,
    ncol = 2,
    top = NULL
  )
}
```

## Ponowne sprawdzenie niestacjonarności zmiennych

```{r sprawdzenie_zmienncyh, echo=FALSE, warning=FALSE, message=FALSE, comment = NA}
stationarity_df <- data.frame(
  Zmienna = colnames(data_stationary),
  Stacjonarnosc = sapply(data_stationary, function(col) {
    if (check_stationarity(ts(col))) {
      return("Stacjonarna")
    } else {
      return("Niestacjonarna")
    }
  })
)


knitr::kable(stationarity_df, row.names = FALSE)
```

## Usunięcie zmiennych o zerowej wariancji

```{r , echo=FALSE, warning=FALSE, message=FALSE, comment = NA}
for (col_name in colnames(data_stationary)) {
  
      col_cv <- sd(data_stationary[[col_name]]) / mean(data_stationary[[col_name]]) * 100
      col_var <- var(data_stationary[[col_name]])
      cat(col_name, "- Współczynnik zmienności:", col_cv, "%, Wariancja: ", col_var,"\n")
}
data_stationary <- data_stationary[!colnames(data_stationary) %in% c("D_INFLATION","D_UNEMPLOYMENT","D_USDPLN")]


#usuwam zmienne o prawie 0 wariancji i helwwig spada



```

## Po usunieciu

```{r , echo=FALSE, warning=FALSE, message=FALSE, comment = NA}
for (col_name in colnames(data_stationary)) {
  
      col_cv <- sd(data_stationary[[col_name]]) / mean(data_stationary[[col_name]]) * 100
      col_var <- var(data_stationary[[col_name]])
      cat(col_name, "- Współczynnik zmienności:", col_cv, "%, Wariancja: ", col_var,"\n")
}
```

\newpage

# Metoda doboru zmiennych

## Metoda Hellwiga

```{r , echo=FALSE, warning=FALSE, message=FALSE, comment = NA}
hellwig_method_original <- function(y, X) {
  all_vars <- colnames(X)
  R <- cor(cbind(y, X))
  r0 <- R[-1, 1]        
  Rxx <- R[-1, -1]      
  results <- list()
  
  for (k in 1:length(all_vars)) {
    combos <- combn(all_vars, k, simplify = FALSE)
    
    for (combo in combos) {
      indices <- match(combo, all_vars)
      r0_sub <- r0[indices]
      Rxx_sub <- Rxx[indices, indices]
      
      h_kj <- numeric(length(indices))
      
      for (j in seq_along(indices)) {
        if (length(indices) == 1) {
          denom <- 1  
        } else {
          denom <- 1 + sum(abs(Rxx_sub[j, -j]))
        }
        h_kj[j] <- (r0_sub[j]^2) / denom
      }
      
      H_k <- sum(h_kj)
      results[[paste(combo, collapse = ", ")]] <- H_k
    }
  }
  
  df <- data.frame(
    Zmienne = names(results),
    Pojemnosc_Hellwiga = round(unlist(results), 4),
    row.names = NULL
  )
  
  df <- df[order(-df$Pojemnosc_Hellwiga), ]
  return(df)
}
X_stat <- data_stationary[, -1]         
Y_stat <- data_stationary["D_CLOSE"]    
hellwig_result <- hellwig_method_original(Y_stat, X_stat)
```

```{r, echo=FALSE, warning=FALSE, message=FALSE, comment = NA}
najlepsza_kombinacja_string <- hellwig_result$Zmienne[1]
best_hellwig_vars <- unlist(strsplit(najlepsza_kombinacja_string, ", "))
cat("Zmienne składowe w najlepszej kombinacji:\n")
for (zmienna in best_hellwig_vars) {
  writeLines(zmienna)
}
cat("Pojemność Hellwiga dla tej kombinacji:", hellwig_result$Pojemnosc_Hellwiga[1], "\n")

zmienne_objaśniające_do_modelu <- unlist(strsplit(najlepsza_kombinacja_string, ", "))



```

# Tworzenie modelu ekonometrycznego

```{r message=FALSE, comment=NA}

formula_modelu <- reformulate(best_hellwig_vars, response = "D_CLOSE")

model <- lm(formula_modelu, data = data_stationary)

print(summary(model))
```

H0 takie ze ... p wynoszace xyz oznacza...

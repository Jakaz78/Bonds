library(readxl)
library(tinytex)
library(ggcorrplot)
library(urca)
library(tseries)
library(ggplot2)
library(dplyr)
library(tidyr)
library(zoo)
data <- read_excel("data2.xlsx")
data <- data[, c("CLOSE", "INFLATION",  "XAUUSD", "USDPLN", "WIG20", "S&P500", "UNEMPLOYMENT", "PMI", "OIL")]
Y <- data["CLOSE"]
X <- data[,c("INFLATION","XAUUSD", "USDPLN","WIG20","S&P500","UNEMPLOYMENT","PMI","OIL")]
data_numeric_interp <- data
summary(data)
numeric_cols <- sapply(data_numeric_interp, is.numeric)
data_numeric_interp[numeric_cols] <- lapply(data_numeric_interp[numeric_cols], function(col) {
na.approx(col, na.rm = FALSE)
})
summary(data_numeric_interp)
summary(X)
print(data_numeric_interp)
print(data)
data <- read_excel("data2.xlsx")
data <- data[, c("CLOSE", "INFLATION",  "XAUUSD", "USDPLN", "WIG20", "S&P500", "UNEMPLOYMENT", "PMI", "OIL")]
Y <- data["CLOSE"]
X <- data[,c("INFLATION","XAUUSD", "USDPLN","WIG20","S&P500","UNEMPLOYMENT","PMI","OIL")]
data_numeric_interp <- data
print(data)
summary(data)
numeric_cols <- sapply(data_numeric_interp, is.numeric)
data_numeric_interp[numeric_cols] <- lapply(data_numeric_interp[numeric_cols], function(col) {
na.approx(col, na.rm = FALSE)
})
print(data_numeric_interp)
summary(data_numeric_interp)
print(data)
print(data_numeric_interp)
summary(data_numeric_interp)
summary(data)
print(numeric_cols)
summary(data)
data <- read_excel("data2.xlsx")
data <- data[, c("CLOSE", "INFLATION", "XAUUSD", "USDPLN", "WIG20", "S&P500", "UNEMPLOYMENT", "PMI", "OIL")]
Y <- data["CLOSE"]
X <- data[,c("INFLATION","XAUUSD", "USDPLN","WIG20","S&P500","UNEMPLOYMENT","PMI","OIL")]
data[] <- lapply(data, function(col) {
na.approx(col, na.rm = FALSE)
})
summary(data)
summary(data)
i <- 0
for (var in non_stationary_vars){
print(non_stationary_vars[i])
i++
}
i <- 0
for (var in non_stationary_vars){
print(non_stationary_vars[i])
i<-i+1
}
---
title: "Sprawozdanie"
library(corrplot)
library(readxl)
library(tinytex)
library(ggcorrplot)
library(urca)
library(tseries)
library(ggplot2)
library(dplyr)
library(tidyr)
library(zoo)
data <- read_excel("data.xlsx")
data <- data[, c("CLOSE", "INFLATION", "XAUUSD", "USDPLN", "WIG20", "S&P500",
"UNEMPLOYMENT", "PMI", "OIL")]
data[] <- lapply(data, function(col) {
na.approx(col, na.rm = FALSE)
})
Y <- data["CLOSE"]
X <- data[,c("INFLATION","XAUUSD", "USDPLN","WIG20","S&P500","UNEMPLOYMENT",
"PMI","OIL")]
summary(Y)
summary(X)
cor_matrix <- cor(data, use = "pairwise.complete.obs", method = "pearson")
corrplot(cor_matrix, method = "color",
order = "hclust",
addCoef.col = "black",
tl.col = "black", tl.cex = 2.5, cl.cex = 2.5, number.cex=2.6)
# Funkcja do testu ADF
adf_result <- function(series, name) {
test <- ur.df(series, type = "trend", selectlags = "AIC")
#cat("Test ADF dla zmiennej:", name, "\n")
#print(summary(test))
#cat("\n\n")
}
# Funkcja do testu KPSS
kpss_result <- function(series, name) {
#cat("Test KPSS dla zmiennej:", name, "\n")
#print(kpss.test(series))
#cat("\n\n")
}
# Funkcja do wykresów
plot_series_diff <- function(series, name) {
df <- data.frame(
Miesiące = 1:length(series),
Series = as.numeric(series),
Diff = c(NA, diff(series))
)
p1 <- ggplot(df, aes(x = Miesiące, y = Series)) +
geom_line(color = "blue") +
labs(title = paste("Szereg czasowy:", name), y = name)
p2 <- ggplot(df, aes(x = Miesiące, y = Diff)) +
geom_line(color = "red") +
labs(title = paste("Pierwsza różnica:", name), y = paste("delta", name))
list(p1, p2)
}
# Funkcja pomocnicza do sprawdzenia stacjonarności
is_non_stationary <- function(series) {
adf <- ur.df(series, type = "trend", selectlags = "AIC")
adf_stat <- adf@teststat[1]
adf_crit <- adf@cval[1, "5pct"]
adf_stationary <- (adf_stat < adf_crit)
kpss <- kpss.test(series)
kpss_stationary <- (kpss$p.value > 0.05)
# Jeśli przynajmniej jeden test mówi, że nie jest stacjonarna → uznaj za niestacjonarną
return(!(adf_stationary & kpss_stationary))
}
# Inicjalizacja pustego wektora
non_stationary_vars <- c()
# Analiza zmiennych
for (var in colnames(X)) {
cat("## Zmienna:", var, "\n\n")
series <- ts(data[[var]])
# Testy
if (is_non_stationary(series)) {
non_stationary_vars <- c(non_stationary_vars, var)
}
# Wykresy
plots <- plot_series_diff(series, var)
print(plots[[1]])
print(plots[[2]])
# Szczegóły testów
adf_result(series, var)
kpss_result(series, var)
}
for (var in non_stationary_vars) {
cat(var, "\n")
}
processed_data_list <- list()
# Przetwarzanie zmiennej objaśnianej (CLOSE)
if ("CLOSE" %in% non_stationary_vars) {
processed_data_list[["CLOSE"]] <- diff(data$CLOSE)
cat("Zmienna CLOSE została zróżnicowana (pierwsza różnica).\n")
} else {
processed_data_list[["CLOSE"]] <- data$CLOSE[-1]
cat("Zmienna CLOSE (stacjonarna) została przycięta o pierwszą obserwację.\n")
}
# Przetwarzanie zmiennych objaśniających (z ramki X)
for (var_name in colnames(X)) {
if (var_name %in% non_stationary_vars) {
processed_data_list[[var_name]] <- diff(data[[var_name]])
cat(paste0("Zmienna ", var_name, " została zróżnicowana (pierwsza różnica).\n"))
} else {
processed_data_list[[var_name]] <- data[[var_name]][-1]
cat(paste0("Zmienna ", var_name, " (stacjonarna) została przycięta o pierwszą obserwację).\n"))
}
}
# Konwersja listy przetworzonych danych na ramkę danych
data_for_helwig <- as.data.frame(processed_data_list)
cat("\nWymiary ramki danych po przetworzeniu dla metody Hellwiga:", dim(data_for_helwig), "\n")
cat("\nStatystyki przetworzonej ramki danych (data_for_helwig):\n")
print(summary(data_for_helwig))
# ========================================
# PRZYGOTOWANIE DANYCH - ANALIZA EKONOMETRYCZNA
# ========================================
library(corrplot)
library(readxl)
library(tinytex)
library(ggcorrplot)
library(urca)
library(tseries)
library(ggplot2)
library(dplyr)
library(tidyr)
library(zoo)
library(forecast)
# ========================================
# PRZYGOTOWANIE DANYCH - ANALIZA EKONOMETRYCZNA
# ========================================
library(corrplot)
library(readxl)
library(tinytex)
library(ggcorrplot)
library(urca)
library(tseries)
library(ggplot2)
library(dplyr)
library(tidyr)
library(zoo)
install.packages("forecast")
library(forecast)
library(VIM)       # do wizualizacji braków danych
# ========================================
# PRZYGOTOWANIE DANYCH - ANALIZA EKONOMETRYCZNA
# ========================================
library(corrplot)
library(readxl)
library(tinytex)
library(ggcorrplot)
library(urca)
library(tseries)
library(ggplot2)
library(dplyr)
library(tidyr)
library(zoo)
install.packages("VIM")
library(forecast)
library(VIM)       # do wizualizacji braków danych
library(car)       # do wykrywania wartości odstających
# ========================================
# 1. WCZYTYWANIE I PODSTAWOWE PRZYGOTOWANIE DANYCH
# ========================================
data <- read_excel("data.xlsx")
# Wybór odpowiednich kolumn
data <- data[, c("CLOSE", "INFLATION", "XAUUSD", "USDPLN", "WIG20", "S&P500",
"UNEMPLOYMENT", "PMI", "OIL")]
# Interpolacja braków danych
data[] <- lapply(data, function(col) {
na.approx(col, na.rm = FALSE)
})
# Sprawdzenie czy pozostały jakieś braki
cat("Liczba braków danych po interpolacji:\n")
print(colSums(is.na(data)))
# ========================================
# 2. LOGARYTMOWANIE ZMIENNYCH
# ========================================
# Identyfikacja zmiennych do logarytmowania (dodatnie wartości)
vars_to_log <- c("XAUUSD", "WIG20", "S&P500", "PMI", "OIL", "USDPLN")
# Sprawdzenie czy zmienne mają wartości dodatnie
cat("\nSprawdzenie wartości minimalnych przed logarytmowaniem:\n")
for(var in vars_to_log) {
min_val <- min(data[[var]], na.rm = TRUE)
cat(paste(var, "- min:", round(min_val, 4), "\n"))
}
# Logarytmowanie wybranych zmiennych
data_log <- data
for(var in vars_to_log) {
if(min(data[[var]], na.rm = TRUE) > 0) {
data_log[[paste0("log_", var)]] <- log(data[[var]])
cat(paste("Zlogarytmowano zmienną:", var, "\n"))
} else {
cat(paste("UWAGA: Zmienna", var, "ma wartości <= 0, pomijam logarytmowanie\n"))
}
}
# ========================================
# 3. ANALIZA STACJONARNOŚCI - ROZSZERZONA
# ========================================
# Funkcja do kompleksowej analizy stacjonarności
analyze_stationarity <- function(series, name, alpha = 0.05) {
cat("\n=== ANALIZA STACJONARNOŚCI DLA:", name, "===\n")
# Test ADF
adf_test <- ur.df(series, type = "trend", selectlags = "AIC")
adf_stat <- adf_test@teststat[1]
adf_crit <- adf_test@cval[1, paste0(alpha*100, "pct")]
adf_stationary <- (adf_stat < adf_crit)
cat("Test ADF:\n")
cat(paste("  Statystyka testowa:", round(adf_stat, 4), "\n"))
cat(paste("  Wartość krytyczna (", alpha*100, "%):", round(adf_crit, 4), "\n"))
cat(paste("  Stacjonarna (ADF):", adf_stationary, "\n"))
# Test KPSS
tryCatch({
kpss_test <- kpss.test(series)
kpss_stationary <- (kpss_test$p.value > alpha)
cat("Test KPSS:\n")
cat(paste("  p-value:", round(kpss_test$p.value, 4), "\n"))
cat(paste("  Stacjonarna (KPSS):", kpss_stationary, "\n"))
# Wynik końcowy
is_stationary <- adf_stationary && kpss_stationary
cat(paste("WYNIK KOŃCOWY - Stacjonarna:", is_stationary, "\n"))
return(list(
stationary = is_stationary,
adf_stat = adf_stat,
adf_pvalue = adf_test@teststat[1],
kpss_pvalue = kpss_test$p.value
))
}, error = function(e) {
cat("Błąd w teście KPSS:", e$message, "\n")
cat(paste("WYNIK KOŃCOWY - Stacjonarna (tylko ADF):", adf_stationary, "\n"))
return(list(stationary = adf_stationary, adf_stat = adf_stat))
})
}
# Analiza wszystkich zmiennych
stationarity_results <- list()
variables_to_analyze <- names(data_log)
for(var in variables_to_analyze) {
if(is.numeric(data_log[[var]])) {
series <- ts(data_log[[var]])
stationarity_results[[var]] <- analyze_stationarity(series, var)
}
}
# Podsumowanie wyników stacjonarności
cat("\n=== PODSUMOWANIE STACJONARNOŚCI ===\n")
non_stationary_vars <- c()
for(var in names(stationarity_results)) {
is_stat <- stationarity_results[[var]]$stationary
cat(paste(var, ":", ifelse(is_stat, "STACJONARNA", "NIESTACJONARNA"), "\n"))
if(!is_stat) {
non_stationary_vars <- c(non_stationary_vars, var)
}
}
# ========================================
# 4. ELIMINACJA NIESTACJONARNOŚCI
# ========================================
data_stationary <- data_log
if(length(non_stationary_vars) > 0) {
cat("\n=== ELIMINACJA NIESTACJONARNOŚCI ===\n")
cat("Zmienne niestacjonarne do przekształcenia:\n")
print(non_stationary_vars)
for(var in non_stationary_vars) {
if(var %in% names(data_stationary)) {
# Pierwsza różnica
diff_series <- diff(data_stationary[[var]])
diff_name <- paste0("diff_", var)
# Dodanie różnicy do data frame (z NA na początku)
data_stationary[[diff_name]] <- c(NA, diff_series)
# Test stacjonarności dla różnicy
if(length(diff_series) > 10) {  # minimum obserwacji dla testu
diff_result <- analyze_stationarity(ts(diff_series), diff_name)
if(diff_result$stationary) {
cat(paste("✓ Pierwsza różnica zmiennej", var, "jest stacjonarna\n"))
# Zastąpienie oryginalnej zmiennej różnicą
data_stationary[[var]] <- data_stationary[[diff_name]]
} else {
cat(paste("✗ Pierwsza różnica zmiennej", var, "nadal niestacjonarna\n"))
# Druga różnica jako ostateczność
second_diff <- diff(diff_series)
if(length(second_diff) > 10) {
second_diff_name <- paste0("diff2_", var)
data_stationary[[second_diff_name]] <- c(NA, NA, second_diff)
second_diff_result <- analyze_stationarity(ts(second_diff), second_diff_name)
if(second_diff_result$stationary) {
cat(paste("✓ Druga różnica zmiennej", var, "jest stacjonarna\n"))
data_stationary[[var]] <- data_stationary[[second_diff_name]]
}
}
}
}
}
}
}
# ========================================
# 5. ELIMINACJA WARTOŚCI ODSTAJĄCYCH
# ========================================
cat("\n=== ELIMINACJA WARTOŚCI ODSTAJĄCYCH ===\n")
# Funkcja do wykrywania wartości odstających metodą IQR
detect_outliers_iqr <- function(x, k = 1.5) {
Q1 <- quantile(x, 0.25, na.rm = TRUE)
Q3 <- quantile(x, 0.75, na.rm = TRUE)
IQR <- Q3 - Q1
lower_bound <- Q1 - k * IQR
upper_bound <- Q3 + k * IQR
outliers <- which(x < lower_bound | x > upper_bound)
return(list(
outliers = outliers,
lower_bound = lower_bound,
upper_bound = upper_bound,
n_outliers = length(outliers)
))
}
# Funkcja do wykrywania wartości odstających metodą Z-score
detect_outliers_zscore <- function(x, threshold = 3) {
z_scores <- abs(scale(x))
outliers <- which(z_scores > threshold)
return(list(
outliers = outliers,
z_scores = as.numeric(z_scores),
n_outliers = length(outliers)
))
}
# Analiza wartości odstających dla każdej zmiennej
outlier_summary <- data.frame(
Variable = character(),
N_Outliers_IQR = numeric(),
N_Outliers_ZScore = numeric(),
Percent_Outliers = numeric(),
stringsAsFactors = FALSE
)
data_clean <- data_stationary
outliers_detected <- list()
for(var in names(data_stationary)) {
if(is.numeric(data_stationary[[var]])) {
series <- data_stationary[[var]]
series_clean <- series[!is.na(series)]
if(length(series_clean) > 10) {
# Wykrywanie metodą IQR
iqr_result <- detect_outliers_iqr(series_clean)
# Wykrywanie metodą Z-score
zscore_result <- detect_outliers_zscore(series_clean)
# Kombinacja obu metod (wartości odstające w obu metodach)
common_outliers <- intersect(iqr_result$outliers, zscore_result$outliers)
cat(paste("\nZmienna:", var))
cat(paste("\n  Wartości odstające (IQR):", iqr_result$n_outliers))
cat(paste("\n  Wartości odstające (Z-score):", zscore_result$n_outliers))
cat(paste("\n  Wspólne wartości odstające:", length(common_outliers)))
# Zapisanie wyników
outlier_summary <- rbind(outlier_summary, data.frame(
Variable = var,
N_Outliers_IQR = iqr_result$n_outliers,
N_Outliers_ZScore = zscore_result$n_outliers,
N_Common_Outliers = length(common_outliers),
Percent_Outliers = round(length(common_outliers) / length(series_clean) * 100, 2)
))
# Usunięcie wspólnych wartości odstających (zachowawcze podejście)
if(length(common_outliers) > 0 && length(common_outliers) < length(series_clean) * 0.05) {
# Usuwamy tylko jeśli to mniej niż 5% danych
outliers_detected[[var]] <- common_outliers
# Zamiana wartości odstających na NA
indices_to_remove <- which(!is.na(series))[common_outliers]
data_clean[[var]][indices_to_remove] <- NA
cat(paste("\n  ✓ Usunięto", length(common_outliers), "wartości odstających"))
} else if(length(common_outliers) >= length(series_clean) * 0.05) {
cat(paste("\n  ⚠ Zbyt dużo wartości odstających (",
round(length(common_outliers)/length(series_clean)*100, 1),
"%) - nie usuwam"))
}
}
}
}
# Wyświetlenie podsumowania wartości odstających
cat("\n\n=== PODSUMOWANIE WARTOŚCI ODSTAJĄCYCH ===\n")
print(outlier_summary)
# ========================================
# 6. KOŃCOWE CZYSZCZENIE DANYCH
# ========================================
# Usunięcie kolumn pomocniczych (różnic)
cols_to_remove <- grep("^diff_|^diff2_", names(data_clean), value = TRUE)
if(length(cols_to_remove) > 0) {
data_clean <- data_clean[, !names(data_clean) %in% cols_to_remove]
}
# Usunięcie wierszy z zbyt dużą liczbą braków
threshold_na <- 0.3  # maksymalnie 30% braków w wierszu
rows_to_keep <- rowSums(is.na(data_clean)) / ncol(data_clean) <= threshold_na
data_final <- data_clean[rows_to_keep, ]
cat(paste("\n=== PODSUMOWANIE KOŃCOWE ==="))
cat(paste("\nLiczba obserwacji przed czyszczeniem:", nrow(data_log)))
cat(paste("\nLiczba obserwacji po czyszczeniu:", nrow(data_final)))
cat(paste("\nLiczba usuniętych obserwacji:", nrow(data_log) - nrow(data_final)))
# Końcowe sprawdzenie braków danych
cat("\n\nLiczba braków danych w końcowym zbiorze:\n")
print(colSums(is.na(data_final)))
# Przygotowanie finalnych zmiennych Y i X
Y_final <- data_final["CLOSE"]
X_final <- data_final[, !names(data_final) %in% "CLOSE"]
# Usunięcie zmiennych o zerowej wariancji
zero_var_cols <- sapply(X_final, function(x) {
if(is.numeric(x)) {
var(x, na.rm = TRUE) == 0 || all(is.na(x))
} else {
FALSE
}
})
if(any(zero_var_cols)) {
cat("\n\nUsuwanie zmiennych o zerowej wariancji:\n")
print(names(X_final)[zero_var_cols])
X_final <- X_final[, !zero_var_cols]
}
cat("\n\n=== FINALNE ZMIENNE ===")
cat("\nZmienna objaśniana (Y):", names(Y_final))
cat("\nZmienne objaśniające (X):")
print(names(X_final))
# Eksport przygotowanych danych
write.csv(data_final, "data_prepared.csv", row.names = FALSE)
cat("\n✓ Przygotowane dane zapisano do pliku: data_prepared.csv")
# ========================================
# 7. WIZUALIZACJE DIAGNOSTYCZNE
# ========================================
# Wykresy przed i po czyszczeniu dla wybranych zmiennych
create_before_after_plots <- function(var_name) {
if(var_name %in% names(data_log) && var_name %in% names(data_final)) {
# Dane przed czyszczeniem
before_data <- data.frame(
index = 1:length(data_log[[var_name]]),
value = data_log[[var_name]],
type = "Przed czyszczeniem"
)
# Dane po czyszczeniu
after_data <- data.frame(
index = 1:length(data_final[[var_name]]),
value = data_final[[var_name]],
type = "Po czyszczeniu"
)
# Połączenie danych
plot_data <- rbind(before_data, after_data)
# Wykres
ggplot(plot_data, aes(x = index, y = value, color = type)) +
geom_line(alpha = 0.7) +
geom_point(alpha = 0.3, size = 0.8) +
facet_wrap(~type, scales = "free_y", ncol = 1) +
labs(title = paste("Porównanie przed i po czyszczeniu:", var_name),
x = "Obserwacja", y = "Wartość") +
theme_minimal() +
theme(legend.position = "none")
}
}
# Przykładowe wykresy dla kluczowych zmiennych
key_vars <- c("CLOSE", "INFLATION", "XAUUSD", "USDPLN")
for(var in key_vars) {
if(var %in% names(data_final)) {
print(create_before_after_plots(var))
}
}
